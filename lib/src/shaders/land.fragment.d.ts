export declare const LAND_FRAGMENT_SHADER = "\n//\n// Fragment Shader for Land\n//\n\nprecision mediump float;\n\nuniform float sineTime;\nuniform float showGrid;\nuniform float zoom;\nuniform sampler2D texture;\nuniform sampler2D hillsNormal;\nuniform sampler2D coastAtlas;\nuniform sampler2D riverAtlas;\nuniform sampler2D mapTexture;\nuniform sampler2D transitionTexture;\nuniform mat3 normalMatrix;\n\nuniform vec3 gridColor;\nuniform float gridWidth;\nuniform float gridOpacity;\n\n// (width, height, cellSize, cellSpacing)\nuniform vec4 textureAtlasMeta;\n\nvarying vec2 vUV;\nvarying vec2 vTexCoord;\nvarying vec3 vPosition;\nvarying float vExtra;\nvarying float vTerrain;\nvarying float vFogOfWar;\nvarying float vHill;\nvarying float vHidden;\nvarying vec2 vOffset;\nvarying vec2 vCoastTextureCell;\nvarying vec2 vRiverTextureCell;\nvarying vec3 vLightDirT;\nvarying vec3 vNeighborsEast;\nvarying vec3 vNeighborsWest;\n\nconst vec3 cameraPos = vec3(0, -25.0, 25.0);\nconst vec3 lightDir = vec3(0.0, -1.0, -1.0);\nconst vec3 lightAmbient = vec3(0.3, 0.3, 0.3);\nconst vec3 lightDiffuse = vec3(1.3, 1.3, 1.3);\n\nconst float hillsNormalMapScale = 0.3; //0.1;\n\nvec2 cellIndexToUV(float idx) {\n    float atlasWidth = textureAtlasMeta.x;\n    float atlasHeight = textureAtlasMeta.y;\n    float cellSize = textureAtlasMeta.z;\n    float cols = atlasWidth / cellSize - 1e-6; // subtract small epsilon to avoid edge cases that cause flickering\n    float rows = atlasHeight / cellSize;\n    float x = mod(idx, cols);\n    float y = floor(idx / cols);\n\n    //return vec2(uv.x * w + u, 1.0 - (uv.y * h + v));\n    return vec2(x / cols + vUV.x / cols, 1.0 - (y / rows + (1.0 - vUV.y) / rows));\n}\n\n/**\n * Uses the texture of a neighboring terrain to blend the given color.\n * @parma color to blend with\n * @param terrain texture atlas index\n * @param sector 0 - 5 (NE - NW) \n */\nvec4 terrainTransition(vec4 inputColor, float terrain, float sector) {\n    if (vTerrain <= 1.0 && terrain > 1.0) return inputColor;\n    vec2 otherUV = cellIndexToUV(terrain);\n    vec2 blendMaskUV = vec2(sector/6.0 + vUV.x / 6.0, 1.0 - vUV.y / 6.0);\n    vec4 color = texture2D(texture, otherUV);\n    vec4 blend = texture2D(transitionTexture, blendMaskUV);\n    float a = min(blend.r, clamp(terrain - vTerrain, 0.0, 1.0));\n    \n    return mix(inputColor, color, a);\n}\n\nvoid main() {\n    // LAND\n    vec4 texColor = texture2D(texture, vTexCoord);\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec2 normalMapUV = vPosition.xy * hillsNormalMapScale;\n\n    /// Transitions to neighboring tiles\n    texColor = terrainTransition(texColor, vNeighborsEast.x, 0.0);\n    texColor = terrainTransition(texColor, vNeighborsEast.y, 1.0);\n    texColor = terrainTransition(texColor, vNeighborsEast.z, 2.0);\n    texColor = terrainTransition(texColor, vNeighborsWest.x, 3.0);\n    texColor = terrainTransition(texColor, vNeighborsWest.y, 4.0);\n    texColor = terrainTransition(texColor, vNeighborsWest.z, 5.0);\n\n    // HILL\n    if (vHill > 0.0) {\n        normal = normalize((texture2D(hillsNormal, normalMapUV).xyz * 2.0) - 1.0);\n        normal = mix(normal, vec3(0.0, 1.0, 0.0), vExtra * vExtra * vExtra); // fade out towards tile edges\n    }\n\n    vec3 lightDir = vLightDirT;\n    float lambertian = max(dot(lightDir, normal), 0.0);\n    //lambertian = sqrt(lambertian);\n\n    vec3 color = lightAmbient * texColor.xyz + lambertian * texColor.xyz * lightDiffuse;\n    gl_FragColor = vec4(color, 1.0);    \n    \n    // comment out following line to show normal vector visualization\n    //gl_FragColor = vec4((normal.x + 1.0 / 2.0, 0.0, 1.0), (normal.y + 1.0 / 2.0, 0.0, 1.0), (normal.z + 1.0 / 2.0, 0.0, 1.0), 1.0);\n    \n    // comment out following line to show normal map texture (UV) coordinates\n    //gl_FragColor = vec4(mod(normalMapUV.x, 1.0), mod(normalMapUV.y, 1.0), 0.0, 1.0);\n\n    // Coast\n    vec2 coastUv = vec2(vCoastTextureCell.x / 8.0 + vUV.x / 8.0, 1.0 - (vCoastTextureCell.y / 8.0 + vUV.y / 8.0));\n    vec4 coastColor = texture2D(coastAtlas, coastUv);\n\n    if (coastColor.w > 0.0) {\n        vec3 coast = lightAmbient * coastColor.xyz + lambertian * coastColor.xyz * lightDiffuse;\n        gl_FragColor = mix(gl_FragColor, vec4(coast, 1.0), coastColor.w);\n    }\n    \n    // River\n    vec2 riverUv = vec2(vRiverTextureCell.x / 8.0 + vUV.x / 8.0, 1.0 - (vRiverTextureCell.y / 8.0 + vUV.y / 8.0));\n    vec4 riverColor = texture2D(riverAtlas, riverUv);\n\n    if (riverColor.w > 0.0) {\n        vec3 river = lightAmbient * riverColor.xyz + lambertian * riverColor.xyz * lightDiffuse;\n        //gl_FragColor = mix(gl_FragColor, vec4(river, 1.0), riverColor.w);\n        gl_FragColor = mix(gl_FragColor, vec4(river, 1.0), riverColor.w);\n    }\n\n    if (showGrid > 0.0 && vExtra > 1.0 - gridWidth) { // hex border\n        gl_FragColor = mix(vec4(gridColor, 1.0), gl_FragColor, 1.0 - gridOpacity);\n    }\n\n    // FOW\n    gl_FragColor = gl_FragColor * (vFogOfWar > 0.0 && vHidden == 0.0 ? 0.66 : 1.0);\n\n    // Map Texture for hidden tiles\n    if (vHidden > 0.0) {\n        gl_FragColor = texture2D(mapTexture, vec2(vPosition.x * 0.05, vPosition.y * 0.05));\n    }    \n}\n";
